- [x] Robust block fetching - goes to backup on failure
- [x] Everywhere blocks - for file index
- [x] UI setup
- [x] Break up big blocks
- [ ] Rebalance on disk changes
    - [x] Revert the code I already wrote
    - [x] Global BlockID list
        - [x] Use an mgr level broadcast to maintain list
            - [x] Struct to hold broadcast and serialize/deserialize it
            - [x] Send the broadcast when adding a BlockId
            - [x] Receive the broadcast and update a list
        - [x] Save that list to disk on update
        - [x] Load that list on startup
        - [x] Periodically pick one node to update all other mgrs with a broadcast
            - [x] Function in mgr that is called once every 12 hours in the main loop
            - [x] Function that serializes the GBL by refactoring save/load functions
            - [x] Enhance the broadcast MGR type to include the GBL
            - [x] Call send the broadcast from the periodic function
            - [x] Receive the broadcast and update your own list if you aren't the main node
    - [ ] If you are the main node, loop through all BlockIDs in your list, for each id:
        - [ ] Verify it exists on the two appropriate disks
            - [ ] Create a new DiskHasBlockReq and DiskHasBlockResp
            - [ ] Send a DiskHasBlockReq to the appropriate node
            - [ ] Receive the DiskHasBlockReq and route to the disk
            - [ ] Disk sends DiskHasBlockResp back to Mgr
            - [ ] Mgr routes the requests back to the appropriate Caller
            - [ ] Receive the DiskHasBlockResp 
        - [ ] If it doesn't fetch the block into memory and send it to the disk
        - [ ] Send a delete to all other disks
    - [ ] Get a list BlockIds on disk(s) into the Mgr - all nodes every hour
    - [ ] Then loop through all BlockIDs on disk, for each id:
        - [ ] If the id doesn't exist in the global list, delete it
- [ ] Update Readme
- [ ] Check for race conditions in tests
- [ ] Hash as filename
- [ ] Delete unused blocks
- [ ] Automatically choose ports
- [ ] Encryption in transit
- [ ] Authentication
- [ ] Combine small blocks
- [ ] UI Refresh
- [ ] XOR background process
- [ ] Service discovery
- [ ] CLI setup